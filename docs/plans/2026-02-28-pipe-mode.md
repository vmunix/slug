# Pipe Mode Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add `--pipe` and `--raw` flags to slugr so it can slugify arbitrary text from stdin without touching the filesystem.

**Architecture:** New `slugify_string()` function in fileslug (skips extension/dotfile handling). CLI adds `--pipe` (stdin→stdout filter mode) and `--raw` (disable filename-aware logic). Pipe mode reads stdin line-by-line, writes slugified output to stdout.

**Tech Stack:** Rust, clap (CLI parsing), fileslug (slugification library)

---

### Task 1: Add `slugify_string()` to fileslug — failing tests

**Files:**
- Modify: `crates/fileslug/src/lib.rs`

**Step 1: Write failing tests for `slugify_string()`**

Add these tests inside the existing `mod tests` block at the bottom of `crates/fileslug/src/lib.rs` (before the closing `}`):

```rust
// --- slugify_string tests ---

#[test]
fn test_slugify_string_basic() {
    let opts = SlugifyOptions::default();
    assert_eq!(slugify_string("My Blog Post Title!", &opts), "my-blog-post-title");
}

#[test]
fn test_slugify_string_no_extension_handling() {
    let opts = SlugifyOptions::default();
    // Unlike slugify(), dots are not treated as extensions
    assert_eq!(slugify_string("my.blog.post", &opts), "my-blog-post");
}

#[test]
fn test_slugify_string_snake() {
    let opts = SlugifyOptions { style: Style::Snake, ..Default::default() };
    assert_eq!(slugify_string("My Blog Post", &opts), "my_blog_post");
}

#[test]
fn test_slugify_string_camel() {
    let opts = SlugifyOptions { style: Style::Camel, ..Default::default() };
    assert_eq!(slugify_string("my blog post", &opts), "myBlogPost");
}

#[test]
fn test_slugify_string_unicode() {
    let opts = SlugifyOptions::default();
    assert_eq!(slugify_string("Café Résumé", &opts), "cafe-resume");
}

#[test]
fn test_slugify_string_keep_unicode() {
    let opts = SlugifyOptions { keep_unicode: true, ..Default::default() };
    assert_eq!(slugify_string("Café Résumé", &opts), "café-résumé");
}

#[test]
fn test_slugify_string_empty() {
    let opts = SlugifyOptions::default();
    assert_eq!(slugify_string("", &opts), "");
}

#[test]
fn test_slugify_string_only_special() {
    let opts = SlugifyOptions::default();
    assert_eq!(slugify_string("@#$!", &opts), "");
}

#[test]
fn test_slugify_string_preserves_version_dots() {
    let opts = SlugifyOptions::default();
    assert_eq!(slugify_string("app version 1.2.3", &opts), "app-version-1.2.3");
}

#[test]
fn test_slugify_string_brackets_stripped() {
    let opts = SlugifyOptions::default();
    assert_eq!(slugify_string("Hello (World) [2024]", &opts), "hello-world-2024");
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test -p fileslug`
Expected: FAIL — `slugify_string` is not defined

**Step 3: Commit failing tests**

```bash
git add crates/fileslug/src/lib.rs
git commit -m "test: add failing tests for slugify_string()"
```

---

### Task 2: Implement `slugify_string()` in fileslug

**Files:**
- Modify: `crates/fileslug/src/lib.rs`

**Step 1: Add the `slugify_string()` function**

Add this function right after the existing `slugify()` function (after line 303, before the `#[cfg(test)]` block):

```rust
/// Slugify an arbitrary string (not a filename).
///
/// Unlike [`slugify`], this treats the entire input as plain text — no
/// extension splitting, no dotfile preservation. Use this for generating
/// URL slugs, identifiers, or other non-filename use cases.
///
/// # Examples
///
/// ```
/// use fileslug::{slugify_string, SlugifyOptions};
///
/// let opts = SlugifyOptions::default();
/// assert_eq!(slugify_string("My Blog Post Title!", &opts), "my-blog-post-title");
/// assert_eq!(slugify_string("Café Résumé", &opts), "cafe-resume");
/// ```
#[must_use]
pub fn slugify_string<'a>(input: &'a str, options: &SlugifyOptions) -> Cow<'a, str> {
    if input.is_empty() {
        return Cow::Borrowed("");
    }

    // Step 1: Transliterate
    let text = if options.keep_unicode {
        input.to_string()
    } else {
        any_ascii::any_ascii(input)
    };

    // Step 2: Strip bracket characters, keep contents
    let text = text.replace(['(', ')', '[', ']', '{', '}'], " ");

    // Step 3: Preserve dots in version numbers
    let text = preserve_version_dots(&text);

    // Step 4: Normalize — collect words
    let words: Vec<String> = if options.keep_unicode {
        text.split(|c: char| !c.is_alphanumeric() && c != VERSION_DOT)
            .filter(|s| !s.is_empty())
            .map(str::to_lowercase)
            .collect()
    } else {
        text.split(|c: char| !c.is_ascii_alphanumeric() && c != VERSION_DOT)
            .filter(|s| !s.is_empty())
            .map(str::to_lowercase)
            .collect()
    };

    if words.is_empty() {
        return Cow::Owned(String::new());
    }

    // Step 5: Join with chosen separator
    let slugified = match options.style {
        Style::Kebab => words.join("-"),
        Style::Snake => words.join("_"),
        Style::Camel => {
            let mut result = String::new();
            for (i, word) in words.iter().enumerate() {
                if i == 0 {
                    result.push_str(word);
                } else {
                    let mut chars = word.chars();
                    if let Some(first) = chars.next() {
                        result.extend(first.to_uppercase());
                        result.push_str(chars.as_str());
                    }
                }
            }
            result
        }
    };

    // Step 6: Restore version dots
    let slugified = restore_version_dots(&slugified);

    // Step 7: Truncate to max length (no extension to account for)
    let slugified = truncate_base(&slugified, "", MAX_FILENAME_BYTES);

    Cow::Owned(slugified)
}
```

**Step 2: Run tests to verify they pass**

Run: `cargo test -p fileslug`
Expected: All tests PASS (existing + new)

**Step 3: Run clippy**

Run: `cargo clippy --all-targets -p fileslug`
Expected: No warnings

**Step 4: Commit**

```bash
git add crates/fileslug/src/lib.rs
git commit -m "feat(fileslug): add slugify_string() for plain text slugification"
```

---

### Task 3: Add `--pipe` and `--raw` CLI flags — failing tests

**Files:**
- Modify: `slugr/src/cli.rs`

**Step 1: Write failing tests for the new flags**

Add these tests inside the existing `mod tests` block in `slugr/src/cli.rs`:

```rust
#[test]
fn test_pipe_flag() {
    let args = Cli::parse_from(["slugr", "--pipe"]);
    assert!(args.pipe);
    assert!(!args.raw);
}

#[test]
fn test_pipe_with_raw() {
    let args = Cli::parse_from(["slugr", "--pipe", "--raw"]);
    assert!(args.pipe);
    assert!(args.raw);
}

#[test]
fn test_raw_requires_pipe() {
    let result = Cli::try_parse_from(["slugr", "--raw", "file.txt"]);
    assert!(result.is_err(), "--raw without --pipe should error");
}

#[test]
fn test_pipe_conflicts_with_execute() {
    let result = Cli::try_parse_from(["slugr", "--pipe", "-x"]);
    assert!(result.is_err(), "--pipe should conflict with -x");
}

#[test]
fn test_pipe_conflicts_with_recursive() {
    let result = Cli::try_parse_from(["slugr", "--pipe", "-r"]);
    assert!(result.is_err(), "--pipe should conflict with -r");
}

#[test]
fn test_pipe_conflicts_with_interactive() {
    let result = Cli::try_parse_from(["slugr", "--pipe", "-i"]);
    assert!(result.is_err(), "--pipe should conflict with -i");
}

#[test]
fn test_pipe_conflicts_with_clobber() {
    let result = Cli::try_parse_from(["slugr", "--pipe", "--clobber"]);
    assert!(result.is_err(), "--pipe should conflict with --clobber");
}

#[test]
fn test_pipe_with_style_flags() {
    let args = Cli::parse_from(["slugr", "--pipe", "--snake"]);
    assert!(args.pipe);
    assert!(args.snake);
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test -p slugr -- cli::tests`
Expected: FAIL — `pipe` and `raw` fields don't exist on `Cli`

**Step 3: Commit failing tests**

```bash
git add slugr/src/cli.rs
git commit -m "test: add failing tests for --pipe and --raw CLI flags"
```

---

### Task 4: Implement `--pipe` and `--raw` CLI flags

**Files:**
- Modify: `slugr/src/cli.rs`

**Step 1: Add the fields to the `Cli` struct**

Add these two fields to the `Cli` struct (after the `keep_unicode` field, before `files`):

```rust
    /// Pipe mode: read text from stdin, write slugified output to stdout
    #[arg(long, conflicts_with_all = ["execute", "clobber", "interactive", "recursive"])]
    pub pipe: bool,

    /// Treat input as raw text, not filenames (skip extension handling). Requires --pipe
    #[arg(long, requires = "pipe")]
    pub raw: bool,
```

**Step 2: Run tests to verify they pass**

Run: `cargo test -p slugr -- cli::tests`
Expected: All CLI tests PASS

**Step 3: Run clippy**

Run: `cargo clippy --all-targets -p slugr`
Expected: No warnings

**Step 4: Commit**

```bash
git add slugr/src/cli.rs
git commit -m "feat(cli): add --pipe and --raw flags"
```

---

### Task 5: Implement pipe mode in main.rs — failing integration tests

**Files:**
- Modify: `slugr/tests/integration.rs`

**Step 1: Write failing integration tests for pipe mode**

Add these tests at the end of `slugr/tests/integration.rs`:

```rust
// --- Pipe mode integration tests ---

#[test]
fn test_pipe_mode_basic() {
    let output = slug_bin()
        .arg("--pipe")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .spawn()
        .and_then(|mut child| {
            child.stdin.take().unwrap().write_all(b"My Cool File.txt\n").unwrap();
            child.wait_with_output()
        })
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert_eq!(stdout.trim(), "my-cool-file.txt");
}

#[test]
fn test_pipe_mode_raw() {
    let output = slug_bin()
        .arg("--pipe")
        .arg("--raw")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .spawn()
        .and_then(|mut child| {
            child.stdin.take().unwrap().write_all(b"My Blog Post Title!\n").unwrap();
            child.wait_with_output()
        })
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert_eq!(stdout.trim(), "my-blog-post-title");
}

#[test]
fn test_pipe_mode_multiple_lines() {
    let output = slug_bin()
        .arg("--pipe")
        .arg("--raw")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .spawn()
        .and_then(|mut child| {
            child.stdin.take().unwrap().write_all(b"Cafe Resume\nHello World\n").unwrap();
            child.wait_with_output()
        })
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    let lines: Vec<&str> = stdout.lines().collect();
    assert_eq!(lines, vec!["cafe-resume", "hello-world"]);
}

#[test]
fn test_pipe_mode_snake_style() {
    let output = slug_bin()
        .arg("--pipe")
        .arg("--raw")
        .arg("--snake")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .spawn()
        .and_then(|mut child| {
            child.stdin.take().unwrap().write_all(b"My Blog Post\n").unwrap();
            child.wait_with_output()
        })
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert_eq!(stdout.trim(), "my_blog_post");
}

#[test]
fn test_pipe_mode_filename_aware_default() {
    let output = slug_bin()
        .arg("--pipe")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .spawn()
        .and_then(|mut child| {
            child.stdin.take().unwrap().write_all(b"My Resume (Final).pdf\n").unwrap();
            child.wait_with_output()
        })
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert_eq!(stdout.trim(), "my-resume-final.pdf");
}

#[test]
fn test_pipe_mode_raw_dots_not_preserved_as_ext() {
    let output = slug_bin()
        .arg("--pipe")
        .arg("--raw")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .spawn()
        .and_then(|mut child| {
            child.stdin.take().unwrap().write_all(b"my.blog.post\n").unwrap();
            child.wait_with_output()
        })
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    assert_eq!(stdout.trim(), "my-blog-post");
}

#[test]
fn test_pipe_mode_empty_line_skipped() {
    let output = slug_bin()
        .arg("--pipe")
        .arg("--raw")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .spawn()
        .and_then(|mut child| {
            child.stdin.take().unwrap().write_all(b"\nHello World\n\n").unwrap();
            child.wait_with_output()
        })
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    let lines: Vec<&str> = stdout.lines().collect();
    assert_eq!(lines, vec!["hello-world"]);
}

#[test]
fn test_pipe_mode_empty_slug_warning() {
    let output = slug_bin()
        .arg("--pipe")
        .arg("--raw")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .stderr(std::process::Stdio::piped())
        .spawn()
        .and_then(|mut child| {
            child.stdin.take().unwrap().write_all(b"@#$!\n").unwrap();
            child.wait_with_output()
        })
        .unwrap();

    assert!(output.status.success());
    let stderr = String::from_utf8(output.stderr).unwrap();
    assert!(stderr.contains("empty"), "expected warning about empty slug, got: {stderr}");
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test -p slugr --test integration`
Expected: FAIL — pipe mode not implemented yet in main.rs

**Step 3: Commit failing tests**

```bash
git add slugr/tests/integration.rs
git commit -m "test: add failing integration tests for pipe mode"
```

---

### Task 6: Implement pipe mode in main.rs

**Files:**
- Modify: `slugr/src/main.rs`

**Step 1: Add pipe mode branch to main()**

In `slugr/src/main.rs`, add the `slugify_string` import. Change line 16 from:

```rust
use fileslug::{slugify, SlugifyOptions};
```

to:

```rust
use fileslug::{slugify, slugify_string, SlugifyOptions};
```

Then, after the `options` binding (after line 27: `};`), insert the pipe mode early return branch before the `let dry_run` line:

```rust
    // Pipe mode: read stdin, slugify, write stdout
    if args.pipe {
        use std::io::Write;
        let stdout = io::stdout();
        let mut out = io::BufWriter::new(stdout.lock());
        let stdin = io::stdin();
        for line in stdin.lock().lines() {
            let line = match line {
                Ok(l) => l,
                Err(e) => {
                    eprintln!("slugr: read error: {e}");
                    return ExitCode::FAILURE;
                }
            };
            if line.is_empty() {
                continue;
            }
            let slugified = if args.raw {
                slugify_string(&line, &options)
            } else {
                slugify(&line, &options)
            };
            if slugified.is_empty() {
                eprintln!("slugr: warning: '{}' slugifies to empty", line);
                continue;
            }
            let _ = writeln!(out, "{slugified}");
        }
        return ExitCode::SUCCESS;
    }
```

**Step 2: Run all tests**

Run: `cargo test --workspace`
Expected: All tests PASS

**Step 3: Run clippy**

Run: `cargo clippy --all-targets --workspace`
Expected: No warnings

**Step 4: Commit**

```bash
git add slugr/src/main.rs
git commit -m "feat: implement pipe mode for stdin-to-stdout text slugification

Closes #2"
```

---

### Task 7: Final verification

**Step 1: Run the full test suite**

Run: `cargo test --workspace`
Expected: All tests pass (previous ~247 + new tests)

**Step 2: Run clippy**

Run: `cargo clippy --all-targets --workspace`
Expected: No warnings

**Step 3: Manual smoke test**

Run these commands and verify output:

```bash
echo "My Blog Post Title!" | cargo run -- --pipe --raw
# Expected: my-blog-post-title

echo "My Resume (Final).pdf" | cargo run -- --pipe
# Expected: my-resume-final.pdf

echo "My Blog Post" | cargo run -- --pipe --raw --snake
# Expected: my_blog_post

printf "Cafe Resume\nHello World\n" | cargo run -- --pipe --raw
# Expected:
# cafe-resume
# hello-world
```

**Step 4: Commit any fixes if needed**
